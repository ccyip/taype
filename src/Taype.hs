{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- |
-- Copyright: (c) 2022 Qianchuan Ye
-- SPDX-License-Identifier: MIT
-- Maintainer: Qianchuan Ye <yeqianchuan@gmail.com>
-- Stability: experimental
-- Portability: portable
--
-- Entry point of the taype language type checker and compiler.
module Taype
  ( main,
  )
where

import Data.Char (toUpper)
import qualified Oil.Syntax as Oil (Program (..), cuteDefs)
import qualified Oil.ToOCaml as Oil (toOCaml)
import Oil.Translation (prelude, toOilProgram)
import Options.Applicative
import System.FilePath
import Taype.Common
import Taype.Cute
import Taype.Environment
import Taype.Error
import Taype.Lexer
import Taype.Parser
import Taype.Syntax
import Taype.TypeChecker

run :: Options -> IO ()
run options@Options {optFile = file, optGeneratePrelude = preludeFile} = do
  whenJust preludeFile $ genPrelude options
  when (null file) $
    if isJust preludeFile
      then exitSuccess
      else
        putStrLn "Taype file must be given unless generating prelude"
          >> exitFailure
  content <- readFileBS file
  let code = decodeUtf8 content
      opt = options {optCode = code}
  result <- runExceptT $ process opt
  whenLeft_ result $ \err -> do
    printDoc opt $ runCuteM opt $ cute err
    exitFailure

process :: Options -> ExceptT Err IO ()
process options@Options {optFile = file, optCode = code, ..} = do
  tokens <- lex file code
  when optPrintTokens $ printTokens file code tokens >> putStr "\n"
  namedDefs <- parse tokens
  let names = fst <$> namedDefs
      srcDefs = closeDefs namedDefs
      srcDoc = cuteDefs options srcDefs
  when optPrintSource $ printDoc options srcDoc
  gctx <- checkDefs options srcDefs
  let coreDefs = defsFromGCtx (fromClosed gctx) names
      coreDoc = cuteDefs options coreDefs
  when optPrintCore $ printDoc options coreDoc
  printToFile (file -<.> "tpc") coreDoc
  let (preludeOil, preludeML) = preludeDocs options
      Oil.Program {..} = toOilProgram options gctx coreDefs
      mainOil = Oil.cuteDefs options mainDefs
      concealOil = Oil.cuteDefs options concealDefs
      revealOil = Oil.cuteDefs options revealDefs
  when (optPrintOil && optPrintPrelude) $ printDoc options preludeOil
  when optPrintOil $ printDoc options $ mainOil <> concealOil <> revealOil
  printToFiles "oil" mainOil concealOil revealOil
  let mainML =
        Oil.toOCaml
          options
          (mkHeader "the main programs as a library")
          ["Driver", "Prelude"]
          mainDefs
      concealML =
        Oil.toOCaml
          options
          (mkHeader "the section functions for the conceal phase")
          ["Driver", "Prelude", modName]
          concealDefs
      revealML =
        Oil.toOCaml
          options
          (mkHeader "the retraction functions for the reveal phase")
          ["Driver", "Prelude", modName]
          revealDefs
  when (optPrintOCaml && optPrintPrelude) $ printDoc options preludeML
  when optPrintOCaml $ printDoc options $ mainML <> concealML <> revealML
  printToFiles "ml" mainML concealML revealML
  where
    capitalize (h : t) = toUpper h : t
    capitalize "" = ""
    printToFile f d = unless optNoFiles $ printDocToFile f d
    printToFiles ext mainDoc concealDoc revealDoc = do
      printToFile (file -<.> ext) mainDoc
      printToFile (dir </> (baseName <> "_conceal") <.> ext) concealDoc
      printToFile (dir </> (baseName <> "_reveal") <.> ext) revealDoc
    dir = takeDirectory file
    baseName = takeBaseName file
    modName = toText $ capitalize baseName

genPrelude :: Options -> FilePath -> IO ()
genPrelude options file = do
  let (preludeOil, preludeML) = preludeDocs options
  printDocToFile (file <.> "oil") preludeOil
  printDocToFile (file <.> "ml") preludeML

preludeDocs :: Options -> (Doc, Doc)
preludeDocs options =
  let preludeOil = Oil.cuteDefs options prelude
      preludeML =
        Oil.toOCaml
          options
          (mkHeader "the prelude of helper types and functions")
          ["Driver"]
          prelude
   in (preludeOil, preludeML)

mkHeader :: Text -> Text
mkHeader what =
  "This file is generated by the taype compiler. It contains "
    <> what
    <> "."

main :: IO ()
main = run =<< execParser (info (opts <**> helper) helpMod)
  where
    helpMod =
      fullDesc
        <> header "taype - a programming language with data types and tape"

opts :: Parser Options
opts = do
  optFile <-
    strArgument $
      metavar "FILE"
        <> value ""
        <> help "Taype source file"
  optInternalNames <-
    switch $
      long "internal-names"
        <> short 'i'
        <> help "Whether to use the internal names for variables"
  optNoFlattenLets <-
    switch $
      long "no-flatten-lets"
        <> help "Do not flatten let bindings"
  optNoFiles <-
    switch $
      long "no-files"
        <> short 'n'
        <> help "Do not generate files"
  optGeneratePrelude <-
    optional $
      strOption $
        long "generate-prelude"
          <> metavar "PRELUDE"
          <> help "Generate the prelude files PRELUDE.oil and PRELUDE.ml"
  optPrintCore <-
    switch $
      long "print-core"
        <> help "Whether to print the generated core taype programs"
  optPrintPrelude <-
    switch $
      long "print-prelude"
        <> help "Whether to print the OIL prelude"
  optPrintOil <-
    switch $
      long "print-oil"
        <> help "Whether to print the generated OIL programs"
  optPrintOCaml <-
    switch $
      long "print-ocaml"
        <> help "Whether to print the generated OIL programs"
  optNamePrefix <-
    strOption $
      long "prefix"
        <> metavar "PREFIX"
        <> value "$"
        <> showDefault
        <> help "Prefix to the internal names (only affects printing)"
  optPrintLabels <-
    switch $
      long "print-labels"
        <> short 'l'
        <> help "Whether to print the leakage labels"
  optPrintTokens <-
    switch $
      long "print-tokens"
        <> help "Whether to print tokens (for internal debugging)"
  optPrintSource <-
    switch $
      long "print-source"
        <> help "Whether to print the source code (for internal debugging)"
  optNoReadableOil <-
    switch $
      long "no-readable-oil"
        <> help "Do not make the generated OIL programs more readable"
  optWidth <-
    optional $
      option auto $
        long "width"
          <> short 'w'
          <> help "Window width (for debugging pretty printer)"
  return Options {optCode = "", ..}
