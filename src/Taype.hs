{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- |
-- Copyright: (c) 2022 Qianchuan Ye
-- SPDX-License-Identifier: MIT
-- Maintainer: Qianchuan Ye <yeqianchuan@gmail.com>
-- Stability: experimental
-- Portability: portable
--
-- Entry point of the taype language type checker and compiler.
module Taype
  ( main,
  )
where

import Data.Char (toUpper)
import qualified Oil.Syntax as Oil (Program (..), cuteDefs)
import qualified Oil.ToOCaml as Oil (toOCaml)
import Oil.Translation (toOilProgram)
import Options.Applicative
import System.FilePath
import Taype.Common
import Taype.Cute
import Taype.Environment
import Taype.Error
import Taype.Lexer
import Taype.Parser
import Taype.Syntax
import Taype.TypeChecker

run :: Options -> IO ()
run options@Options {optFile = file} = do
  content <- readFileBS file
  let code = decodeUtf8 content
      opt = options {optCode = code}
  result <- runExceptT $ process opt
  whenLeft_ result $ \err -> do
    printDoc opt $ runCuteM opt $ cute err
    exitFailure

process :: Options -> ExceptT Err IO ()
process options@Options {optFile = file, optCode = code, ..} = do
  tokens <- lex file code
  when optPrintTokens $ printTokens file code tokens >> putStr "\n"
  namedDefs <- parse tokens
  let names = fst <$> namedDefs
      srcDefs = closeDefs namedDefs
      srcDoc = cuteDefs options srcDefs
  when optPrintSource $ printDoc options srcDoc
  gctx <- checkDefs options srcDefs
  let coreDefs = defsFromGCtx (fromClosed gctx) names
      coreDoc = cuteDefs options coreDefs
  when optPrintCore $ printDoc options coreDoc
  printDocToFile (file -<.> "tpc") coreDoc
  let Oil.Program {..} = toOilProgram options gctx coreDefs
      preludeOil = Oil.cuteDefs options preludeDefs
      mainOil = Oil.cuteDefs options mainDefs
      concealOil = Oil.cuteDefs options concealDefs
      revealOil = Oil.cuteDefs options revealDefs
  when (optPrintOil && optPrintPrelude) $ printDoc options preludeOil
  when optPrintOil $ printDoc options $ mainOil <> concealOil <> revealOil
  printDocsToFile "oil" preludeOil mainOil concealOil revealOil
  let preludeML =
        Oil.toOCaml
          options
          (mkHeader "the prelude of helper types and functions")
          ["Driver"]
          preludeDefs
      mainML =
        Oil.toOCaml
          options
          (mkHeader "the main programs as a library")
          ["Driver", "Prelude"]
          mainDefs
      concealML =
        Oil.toOCaml
          options
          (mkHeader "the section functions for the conceal phase")
          ["Driver", "Prelude", modName]
          concealDefs
      revealML =
        Oil.toOCaml
          options
          (mkHeader "the retraction functions for the reveal phase")
          ["Driver", "Prelude", modName]
          revealDefs
  when (optPrintOCaml && optPrintPrelude) $ printDoc options preludeML
  when optPrintOCaml $ printDoc options $ mainML <> concealML <> revealML
  printDocsToFile "ml" preludeML mainML concealML revealML
  where
    capitalize (h : t) = toUpper h : t
    capitalize "" = ""
    mkHeader what =
      "This file is generated by the taype compiler. \
      \It contains "
        <> what
        <> "."
    printDocsToFile ext preludeDoc mainDoc concealDoc revealDoc = do
      printDocToFile (dir </> "prelude" <.> ext) preludeDoc
      printDocToFile (file -<.> ext) mainDoc
      printDocToFile (dir </> (baseName <> "_conceal") <.> ext) concealDoc
      printDocToFile (dir </> (baseName <> "_reveal") <.> ext) revealDoc
    dir = takeDirectory file
    baseName = takeBaseName file
    modName = toText $ capitalize baseName

main :: IO ()
main = run =<< execParser (info (opts <**> helper) helpMod)
  where
    helpMod =
      fullDesc
        <> header "taype - a programming language with data types and tape"

opts :: Parser Options
opts = do
  optFile <-
    strArgument $
      metavar "FILE" <> help "Taype source file"
  optInternalNames <-
    switch $
      long "internal-names"
        <> short 'i'
        <> help "Whether to use the internal names for variables"
  optNoFlattenLets <-
    switch $
      long "no-flatten-lets"
        <> help "Do not flatten let bindings"
  optPrintCore <-
    switch $
      long "print-core"
        <> help "Whether to print the generated core taype programs"
  optPrintPrelude <-
    switch $
      long "print-prelude"
        <> help "Whether to print the OIL prelude"
  optPrintOil <-
    switch $
      long "print-oil"
        <> help "Whether to print the generated OIL programs"
  optPrintOCaml <-
    switch $
      long "print-ocaml"
        <> help "Whether to print the generated OIL programs"
  optNamePrefix <-
    strOption $
      long "prefix"
        <> metavar "PREFIX"
        <> value "$"
        <> showDefault
        <> help "Prefix to the internal names (only affects printing)"
  optPrintLabels <-
    switch $
      long "print-labels"
        <> short 'l'
        <> help "Whether to print the leakage labels"
  optPrintTokens <-
    switch $
      long "print-tokens"
        <> help "Whether to print tokens (for internal debugging)"
  optPrintSource <-
    switch $
      long "print-source"
        <> help "Whether to print the source code (for internal debugging)"
  optNoReadableOil <-
    switch $
      long "no-readable-oil"
        <> help "Do not make the generated OIL programs more readable"
  optWidth <-
    optional $
      option auto $
        long "width"
          <> short 'w'
          <> help "Window width (for debugging pretty printer)"
  return Options {optCode = "", ..}
