{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- |
-- Copyright: (c) 2022-2023 Qianchuan Ye
-- SPDX-License-Identifier: MIT
-- Maintainer: Qianchuan Ye <yeqianchuan@gmail.com>
-- Stability: experimental
-- Portability: portable
--
-- Entry point of the taype language type checker and compiler.
module Taype
  ( main,
  )
where

import Data.Char (toUpper)
-- import qualified Oil.Syntax as Oil (Program (..), cuteDefs)
-- import qualified Oil.ToOCaml as Oil (toOCaml)
-- import Oil.Translation (prelude, toOilProgram)
import Options.Applicative
import System.FilePath
import Taype.Common
import Taype.Cute
import Taype.Environment
import Taype.Error
import Taype.Lexer
import Taype.Parser
import Taype.Syntax
import Taype.TypeChecker

run :: Options -> IO ()
run options@Options {optFile = file} = do
  content <- readFileBS file
  let code = decodeUtf8 content
      opt = options {optCode = code}
  result <- runExceptT $ process opt
  whenLeft_ result $ \err -> do
    printDoc opt $ runCuteM opt $ cute err
    exitFailure

process :: Options -> ExceptT Err IO ()
process options@Options {optFile = file, optCode = code, ..} = do
  tokens <- lex file code
  when optPrintTokens $ printTokens file code tokens >> putStr "\n"
  namedDefs <- parse tokens
  let names = fst <$> namedDefs
      srcDefs = closeDefs namedDefs
      srcDoc = cuteDefs options srcDefs
  when optPrintSource $ printDoc options srcDoc
  gctx <- checkDefs options srcDefs
  let coreDefs = defsFromGCtx gctx names
      coreDefs' = if optReadable then readableDefs coreDefs else coreDefs
      coreDoc =
        cuteDefs options (fromClosedDefs coreDefs')
  when optPrintCore $ printDoc options coreDoc
  -- printToFile (file -<.> "tpc") coreDoc
  -- prog <- lift $ toOilProgram options gctx coreDefs
  -- let (preludeOil, preludeML) = preludeDocs options
  --     Oil.Program {..} = fromClosed prog
  --     mainOil = Oil.cuteDefs options mainDefs
  --     concealOil = Oil.cuteDefs options concealDefs
  --     revealOil = Oil.cuteDefs options revealDefs
  -- when (optPrintOil && optPrintPrelude) $ printDoc options preludeOil
  -- when optPrintOil $ printDoc options $ mainOil <> concealOil <> revealOil
  -- printToFiles "oil" mainOil concealOil revealOil
  -- let mainML =
  --       Oil.toOCaml
  --         options
  --         (mkHeader "the main programs as a library")
  --         ["Driver", "Prelude"]
  --         mainDefs
  --     concealML =
  --       Oil.toOCaml
  --         options
  --         (mkHeader "the section functions for the conceal phase")
  --         ["Driver", "Prelude", modName]
  --         concealDefs
  --     revealML =
  --       Oil.toOCaml
  --         options
  --         (mkHeader "the retraction functions for the reveal phase")
  --         ["Driver", "Prelude", modName]
  --         revealDefs
  -- when (optPrintOCaml && optPrintPrelude) $ printDoc options preludeML
  -- when optPrintOCaml $ printDoc options $ mainML <> concealML <> revealML
  -- printToFiles "ml" mainML concealML revealML
  -- where
  --   capitalize (h : t) = toUpper h : t
  --   capitalize "" = ""
  --   printToFile f d = unless optNoFiles $ printDocToFile f d
  --   printToFiles ext mainDoc concealDoc revealDoc = do
  --     printToFile (file -<.> ext) mainDoc
  --     printToFile (dir </> (baseName <> "_conceal") <.> ext) concealDoc
  --     printToFile (dir </> (baseName <> "_reveal") <.> ext) revealDoc
  --   dir = takeDirectory file
  --   baseName = takeBaseName file
  --   modName = toText $ capitalize baseName

mkHeader :: Text -> Text
mkHeader what =
  "This file is generated by the taype compiler. It contains "
    <> what
    <> "."

main :: IO ()
main = run =<< execParser (info (opts <**> helper) helpMod)
  where
    helpMod =
      fullDesc
        <> header "taype - a programming language with data types and tape"

opts :: Parser Options
opts = do
  optFile <-
    strArgument $
      metavar "FILE"
        <> value ""
        <> help "Taype source file"
  optInternalNames <-
    switch $
      long "internal-names"
        <> short 'i'
        <> help "Whether to print the internal names for variables"
  optNoFlattenLets <-
    switch $
      long "no-flatten-lets"
        <> help "Do not flatten let bindings"
  optNoFiles <-
    switch $
      long "no-files"
        <> short 'n'
        <> help "Do not generate files"
  optFlagNoOptimization <-
    switch $
      long "fno-opt"
        <> help "Disable all optimization"
  optFlagNoSimplify <-
    switch $
      long "fno-simplify"
        <> help "Disable simplifier"
  optFlagNoTupling <-
    switch $
      long "fno-tupling"
        <> help "Disable tupling optimization"
  optPrintCore <-
    switch $
      long "print-core"
        <> help "Whether to print the generated core taype programs"
  optPrintPrelude <-
    switch $
      long "print-prelude"
        <> help "Whether to print the OIL prelude"
  optPrintOil <-
    switch $
      long "print-oil"
        <> help "Whether to print the generated OIL programs"
  optPrintOCaml <-
    switch $
      long "print-ocaml"
        <> help "Whether to print the generated OIL programs"
  optNamePrefix <-
    strOption $
      long "prefix"
        <> metavar "PREFIX"
        <> value "$"
        <> showDefault
        <> help "Prefix to the internal names (only affects printing)"
  optPrintTokens <-
    switch $
      long "print-tokens"
        <> help "Whether to print tokens (for internal debugging)"
  optPrintSource <-
    switch $
      long "print-source"
        <> help "Whether to print the source code (for internal debugging)"
  optReadable <-
    switch $
      long "readable"
        <> help "Make the generated programs more readable (for debugging)"
  optWidth <-
    optional $
      option auto $
        long "width"
          <> short 'w'
          <> help "Window width (for debugging pretty printer)"
  return
    Options
      { optCode = "",
        optFlagNoSimplify = optFlagNoSimplify || optFlagNoOptimization,
        optFlagNoTupling = optFlagNoTupling || optFlagNoOptimization,
        ..
      }
