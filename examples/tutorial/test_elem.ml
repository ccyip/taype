(* In this example, we show how we can use the oblivious libraries generated by
   the Taype compiler, and how we test our examples. Note that most code here
   and the imported modules are only for obtaining the inputs to the library
   functions and interpreting the output. This is specific to our testing
   method. You may have a different way to do IO. *)

(* First we import a module that defines some common routines, e.g., parsing
   command line arguments, which we use across all our examples. *)
open Common

(* We then parse the command line arguments, which returns a first-class module
   that implements the crypto primitives. *)
module Driver = (val parse_options ())
open Driver

(* The following few modules (functors) are specialized by the [Driver]
   module. *)

(* This functor in the [Common] module defines some handy routines to streamline
   the test programs. *)
open Setup (Driver)

(* This is the oblivious library generated by the Taype compiler. It also
   contains two modules called [Conceal] and [Reveal] for the conceal and reveal
   phases. *)
open Tutorial.M (Driver)

(* This is the helper module that converts s-expressions from and to our data
   ([list] in this case). *)
open Tutorial_helper.M (Driver)

let () =
  (* We first setup the driver. This function is provided by the driver, mostly
     setting up necessary crypto contexts and network, etc. *)
  setup_driver_simple ();

  (* The input of the program is specified in "test_elem.input.csv", which will
     be read in the next few lines of code. All input is in s-expression. *)

  (* Read the maximum length of the input list. This is the public view, so
     every party gets the same public value here. *)
  let n = get_public_int () in
  (* Obtain an oblivious list. The party who owns the private list reads it from
     the input, and "encrypt" it with [Conceal.obliv_list_s]. The other parties
     do not have this private list, but still participate in the encryption by
     calling [Conceal.obliv_list_s_for]. The first argument to [get_private] is
     used to convert the input s-expression to the list defined in the Taype
     library. In this case, [mylist_of_sexp_check] also checks the public view
     [n] is valid, i.e. it is not smaller than the actual size of the list. *)
  let xs =
    get_private (mylist_of_sexp_check n) (Conceal.obliv_list_s n)
      (Conceal.obliv_list_s_for n)
  in
  (* Obtain an oblivious integer, which is the element we check. *)
  let y = get_private_int () in
  (* Read the expected result. *)
  let expected = get_expected_bool () in

  (* We want to collect performance statistics. *)
  collect_stat ();

  (* Perform the core oblivious computation, [obliv_elem] in this case. *)
  let res = obliv_elem y xs in

  (* Save the performance statistics. *)
  record_stat ();

  (* Reveal the result. *)
  let res = Reveal.obliv_bool_r res in

  (* Clean up the driver. *)
  finalize_driver ();

  (* We check if the revealed result actually matches the expected value. This
     line outputs the collected performance statistics if they match, or prints
     out "failed" otherwise. The performance statistics is the number of MUXes
     if we use the plaintext driver, or the running time (in microseconds) of
     the oblivious computation if we use the emp-toolkit driver. *)
  expected = res |> print_result
