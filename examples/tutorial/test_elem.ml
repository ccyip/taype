(* (\* In this example, we show how we can use the oblivious libraries generated by *)
(*    the Taype compiler, and how we test our examples. Note that most code here *)
(*    and the imported modules are only for obtaining the inputs to the library *)
(*    functions and interpreting the output. This is specific to our testing *)
(*    method. You may have a different way to do IO. *\) *)

(* (\* First we import the driver which implements the crypto primitives. *\) *)
(* open Driver *)
(* (\* This module defines some common routines, e.g., parsing command line *)
(*    arguments, that we use across all our examples. *\) *)
(* open Common *)
(* (\* The test input is in s-expression. *\) *)
(* open Sexplib *)
(* (\* This is the Taype prelude generated by the Taype compiler. *\) *)
(* open Prelude *)
(* (\* The main oblivious library generated by the Taype compiler. *\) *)
(* open Tutorial *)
(* (\* The generated library for the conceal phase. It contains functions for *)
(*    encrypting private data (private_s_list in this case). *\) *)
(* open Tutorial_conceal *)
(* (\* The generated library for the reveal phase. It contains functions for *)
(*    decrypting oblivious data (unsafe_r_list in this case). *\) *)
(* open Tutorial_reveal *)
(* (\* A helper module that converts s-expressions from and to our data (list in this case). *\) *)
(* open Tutorial_helper *)

(* let _ = *)
(*   (\* First we parse the commandline options. This tells us what party we are. *\) *)
(*   parse_options (); *)
(*   (\* We then setup the driver. This function is provided by the driver, mostly *)
(*      setting up necessary crypto contexts and network, etc. *\) *)
(*   setup_driver_simple (); *)

(*   (\* The input of the program is specified in "test_elem.input.csv", which will *)
(*      be read in the next few lines of code. All input is in s-expression. *\) *)

(*   (\* Read the maximum length of the input list. This is the public view, so *)
(*      every party gets the same public value here. *\) *)
(*   let n = get_public_int () in *)
(*   (\* Calculate the size of the oblivious list. The parties who do not own the *)
(*      private list need this information to jointly compute the "encrypted" list *)
(*      with the party who owns it. This function is part of the generated *)
(*      oblivious library (`list). *\) *)
(*   let size = obliv_list n in *)
(*  (\* Obtain an oblivious list. The party who owns the private list reads it from *)
(*      the input, and "encrypt" it with [private_s_list]. The other parties do not *)
(*      have this private list, but still participate in the encryption. The first *)
(*      argument to [get_private] is used to convert the input s-expression to the *)
(*      list defined in the Taype library. In this case, [mylist_of_sexp_check] *)
(*      also checks the public view [n] is valid, i.e. it is not smaller than the *)
(*      actual size of the list. *\) *)
(*   let obliv_xs = get_private (mylist_of_sexp_check n) (private_s_list n) size in *)
(*   (\* Obtain an oblivious integer, which is the element we check. *\) *)
(*   let obliv_x = get_private_int () in *)
(*   (\* Read the expected result. *\) *)
(*   let expected = get_expected Conv.bool_of_sexp in *)

(*   (\* We want to collect performance statistics. *\) *)
(*   collect_stat (); *)

(*   (\* Perform the core oblivious computation, [obliv_elem] in this case. *\) *)
(*   let obliv_res = obliv_elem n obliv_x obliv_xs in *)

(*   (\* Save the performance statistics. *\) *)
(*   record_stat (); *)

(*   (\* Reveal the result. *\) *)
(*   let res = unsafe_r_bool obliv_res in *)

(*   (\* Clean up the driver. *\) *)
(*   finalize_driver (); *)

(*   (\* We check if the revealed result actually matches the expected value. This *)
(*      line outputs the collected performance statistics if they match, or prints *)
(*      out "failed" otherwise. The performance statistics is the number of MUXes *)
(*      if we use the plaintext driver, or the running time (in microseconds) of *)
(*      the oblivious computation if we use the emp-toolkit driver. *\) *)
(*   expected = res |> print_result *)
