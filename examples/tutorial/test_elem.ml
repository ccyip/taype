(* In this example, we show how we can use the oblivious libraries generated by
   the Taype compiler, and how we test our examples. Note that most of the
   imported libraries and code in this file are only for I/O, e.g., parsing
   commandline arguments, obtaining the inputs to the library functions and
   interpreting the output. This is specific to our testing method. You may
   choose a different way to do I/O in your applications. *)

(* First we import a module that defines some common routines, e.g., parsing
   command line arguments, which we use across all our examples. *)
open Common

(* We then parse the command line arguments, which returns a first-class module
   that implements the crypto primitives. *)
module Driver = (val parse_options ())
open Driver

(* The following modules (functors) are specialized by the [Driver] module. *)

(* This functor in the [Common] module defines some handy routines to streamline
   the test programs. *)
open Setup (Driver)

(* This is the oblivious library generated by the Taype compiler. It also
   contains two modules called [Conceal] and [Reveal] for the conceal and reveal
   phases. *)
open Tutorial.M (Driver)

(* This is the helper module that converts s-expressions from and to our data
   ([list] in this case). *)
open Tutorial_helper.M (Driver)

let () =
  (* We first setup the driver. This function is provided by the driver, mostly
     setting up necessary crypto contexts and network, etc. *)
  setup_driver_simple ();

  (* An example of the input format is available in files
   "test_elem.alice.input" and "test_elem.bob.input". Our test framework takes a
   csv file (e.g., "test_elem.input.csv") that specifies multiple test cases and
   generates input and run the program in batch. The next few lines of code read
   input. All input is in s-expression. *)

  (* Read the maximum length of the input list. This is the public view, so
     every party gets the same public value here. *)
  let n = get_public_int () in
  (* Obtain an oblivious list. The party who owns the private list reads it from
     the input, and "encrypt" it with [Conceal.obliv_list_s]. The other parties
     do not have this private list, but still participate in the encryption by
     calling [Conceal.obliv_list_s_for]. The first argument to [get_private] is
     used to convert the input s-expression to the list defined in the Taype
     library. In this case, [mylist_of_sexp_check] also checks the public view
     [n] is valid, i.e. it is not smaller than the actual size of the list. *)
  let xs =
    get_private (mylist_of_sexp_check n) (Conceal.obliv_list_s n)
      (Conceal.obliv_list_s_for n)
  in
  (* Obtain an oblivious integer, which is the element for the membership check. *)
  let y = get_private_int () in
  (* Read the expected result. *)
  let expected = get_expected_bool () in

  (* We want to collect performance statistics. *)
  collect_stat ();

  (* Perform the core oblivious computation, [obliv_elem] in this case. *)
  let res = obliv_elem y xs in

  (* Save the performance statistics. *)
  record_stat ();

  (* Reveal the result. *)
  let res = Reveal.obliv_bool_r res in

  (* Clean up the driver. *)
  finalize_driver ();

  (* We check if the revealed result actually matches the expected value. This
     line outputs the collected performance statistics if they match, or prints
     out "failed" otherwise. The performance statistics is the number of MUXes
     if we use the plaintext driver, or the running time (in microseconds) of
     the oblivious computation if we use the emp-toolkit driver. *)
  expected = res |> print_result
