data list = Nil | Cons int list

fn elem : int -> list -> bool = \ x xs ->
  case xs of
  | Nil -> False
  | Cons y xs' -> x == y || elem x xs'
  end

fn insert : int -> list -> list = \ x xs ->
  case xs of
  | Nil -> Cons x Nil
  | Cons y xs' -> if x <= y then Cons x xs else Cons y (insert x xs')
  end

-- The two lists are of the same length.
fn hamming_distance : list -> list -> int = \xs ys ->
  case xs of
  | Nil -> 0
  | Cons x xs' ->
    case ys of
    | Nil -> 0
    | Cons y ys' ->
      let d = hamming_distance xs' ys'
       in if x == y then d else d + 1
    end
  end

-- The two lists have the same length.
fn dot_prod : list -> list -> int = \xs ys ->
  case xs of
  | Nil -> 0
  | Cons x xs' ->
    case ys of
    | Nil -> 0
    | Cons y ys' ->
      x * y + dot_prod xs' ys'
    end
  end

fn min_euclidean_distance_with : list -> int -> int -> int = \xs y min ->
  case xs of
  | Nil -> min
  | Cons x xs' ->
    let min' = min_euclidean_distance_with xs' y min
        d = x - y
        cur = d * d
     in if cur <= min' then cur else min'
  end

fn min_euclidean_distance : list -> int -> int = \xs y ->
  case xs of
  | Nil -> (-1)
  | Cons x xs' ->
    let d = x - y
        cur = d * d
     in min_euclidean_distance_with xs' y cur
  end

fn map : (int -> int) -> list -> list = \f xs ->
  case xs of
  | Nil -> Nil
  | Cons x xs' -> Cons (f x) (map f xs')
  end

fn filter : (int -> bool) -> list -> list = \f xs ->
  case xs of
  | Nil -> Nil
  | Cons x xs' ->
    if f x
    then Cons x (filter f xs')
    else filter f xs'
  end

----------------------------------------------------------------
-- Oblivious types

obliv `list (k : int) =
  if k == 0
  then unit
  else unit `+ `int `* `list (k-1)

#[section]
fn s_list : (k : int) -> list -> `list k = \ k xs ->
  if k == 0
  then ()
  else tape (case xs of
             | Nil -> `inl ()
             | Cons x xs' -> `inr `(tape (s_int x), s_list (k-1) xs')
             end)

#[retraction]
fn r_list : (k : int) -> `list k -> list = \ k ->
  if k == 0
  then \ _ -> Nil
  else \ xs -> `case xs of
               | `inl _ -> Nil
               | `inr p -> `case p of
                           `(x, xs') -> Cons (r_int x) (r_list (k-1) xs')
                           end
               end

----------------------------------------------------------------
-- Lifted functions

#[safe]
fn `elem : (k : int) -> `int -> `list k -> `bool = \ k x xs ->
  tape (s_bool (elem (r_int x) (r_list k xs)))

#[safe]
fn `insert : (k : int) -> `int -> `list k -> `list (k+1) = \ k x xs ->
  s_list (k+1) (insert (r_int x) (r_list k xs))

#[safe]
fn `hamming_distance : (k : int) -> `list k -> `list k -> `int = \k xs ys ->
  tape (s_int (hamming_distance (r_list k xs) (r_list k ys)))

#[safe]
fn `dot_prod : (k : int) -> `list k -> `list k -> `int = \k xs ys ->
  tape (s_int (dot_prod (r_list k xs) (r_list k ys)))

#[safe]
fn `min_euclidean_distance : (k : int) -> `list k -> `int -> `int = \k xs y ->
  tape (s_int (min_euclidean_distance (r_list k xs) (r_int y)))

#[safe]
fn `test_map : (k : int) -> `list k -> `int -> `list k = \k xs y ->
  s_list k (map (\x -> x + r_int y) (r_list k xs))

#[safe]
fn `test_filter : (k : int) -> `list k -> `int -> `list k = \k xs y ->
  s_list k (filter (\x -> x <= r_int y) (r_list k xs))
