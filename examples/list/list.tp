data list = Nil | Cons int list

fn elem : int -> list -> bool = \ x xs ->
  case xs of
  | Nil -> False
  | Cons y xs' -> x == y || elem x xs'
  end

fn insert : int -> list -> list = \ x xs ->
  case xs of
  | Nil -> Cons x Nil
  | Cons y xs' -> if x <= y then Cons x xs else Cons y (insert x xs')
  end

-- The two lists are of the same length.
fn hamming_distance : list -> list -> int = \xs ys ->
  case xs of
  | Nil -> 0
  | Cons x xs' ->
    case ys of
    | Nil -> 0
    | Cons y ys' ->
      let d = hamming_distance xs' ys'
       in if x == y then d else d + 1
    end
  end

-- The two lists have the same length.
fn dot_prod : list -> list -> int = \xs ys ->
  case xs of
  | Nil -> 0
  | Cons x xs' ->
    case ys of
    | Nil -> 0
    | Cons y ys' ->
      x * y + dot_prod xs' ys'
    end
  end

fn min_euclidean_distance_with : list -> int -> int -> int = \xs y min ->
  case xs of
  | Nil -> min
  | Cons x xs' ->
    let min' = min_euclidean_distance_with xs' y min
        d = x - y
        cur = d * d
     in if cur <= min' then cur else min'
  end

fn min_euclidean_distance : list -> int -> int = \xs y ->
  case xs of
  | Nil -> (-1)
  | Cons x xs' ->
    let d = x - y
        cur = d * d
     in min_euclidean_distance_with xs' y cur
  end

fn nth : int -> list -> int = \i xs ->
  case xs of
  | Nil -> 0
  | Cons x xs -> if i == 0 then x else nth (i-1) xs
  end

fn insert_list : list -> list -> list = \xs ys ->
  case ys of
  | Nil -> xs
  | Cons y ys' -> insert_list (insert y xs) ys'
  end

fn map : (int -> int) -> list -> list = \f xs ->
  case xs of
  | Nil -> Nil
  | Cons x xs' -> Cons (f x) (map f xs')
  end

fn filter : (int -> bool) -> list -> list = \f xs ->
  case xs of
  | Nil -> Nil
  | Cons x xs' ->
    if f x
    then Cons x (filter f xs')
    else filter f xs'
  end

fn append : list -> list -> list = \xs ys ->
  case xs of
  | Nil -> ys
  | Cons x xs -> Cons x (append xs ys)
  end

fn take : int -> list -> list = \n xs ->
  case xs of
  | Nil -> Nil
  | Cons x xs ->
    if n == 0 then Nil else Cons x (take (n-1) xs)
  end

fn concat_map : (int -> list) -> list -> list = \f xs ->
  case xs of
  | Nil -> Nil
  | Cons x xs -> append (f x) (concat_map f xs)
  end

fn partition : (int -> bool) -> list -> list * list = \f xs ->
  case xs of
  | Nil -> (Nil, Nil)
  | Cons x xs' ->
    case partition f xs' of
    (ts, fs) -> if f x then (Cons x ts, fs) else (ts, Cons x fs)
    end
  end

fn span : (int -> bool) -> list -> list * list = \f xs ->
  case xs of
  | Nil -> (Nil, Nil)
  | Cons x xs' ->
    if f x
    then case span f xs' of
         (l, r) -> (Cons x l, r)
         end
    else (Nil, xs)
  end

----------------------------------------------------------------
-- Oblivious types

obliv `list (k : int) =
  if k == 0
  then unit
  else unit `+ `int `* `list (k-1)

#[section]
fn s_list : (k : int) -> list -> `list k = \ k xs ->
  if k == 0
  then ()
  else tape (case xs of
             | Nil -> `inl ()
             | Cons x xs' -> `inr `(tape (s_int x), s_list (k-1) xs')
             end)

#[retraction]
fn r_list : (k : int) -> `list k -> list = \ k ->
  if k == 0
  then \ _ -> Nil
  else \ xs -> `case xs of
               | `inl _ -> Nil
               | `inr p -> `case p of
                           `(x, xs') -> Cons (r_int x) (r_list (k-1) xs')
                           end
               end

----------------------------------------------------------------
-- Lifted functions

#[safe]
fn `elem : (k : int) -> `int -> `list k -> `bool = \ k x xs ->
  tape (s_bool (elem (r_int x) (r_list k xs)))

#[safe]
fn `insert : (k : int) -> `int -> `list k -> `list (k+1) = \ k x xs ->
  s_list (k+1) (insert (r_int x) (r_list k xs))

#[safe]
fn `hamming_distance : (k : int) -> `list k -> `list k -> `int = \k xs ys ->
  tape (s_int (hamming_distance (r_list k xs) (r_list k ys)))

#[safe]
fn `dot_prod : (k : int) -> `list k -> `list k -> `int = \k xs ys ->
  tape (s_int (dot_prod (r_list k xs) (r_list k ys)))

#[safe]
fn `min_euclidean_distance : (k : int) -> `list k -> `int -> `int = \k xs y ->
  tape (s_int (min_euclidean_distance (r_list k xs) (r_int y)))

#[safe]
fn `nth : (k : int) -> `int -> `list k -> `int = \ k x xs ->
  tape (s_int (nth (r_int x) (r_list k xs)))

#[safe]
fn `insert_list : (k : int) -> `list k -> `list k -> `list (k+k) =
  \ k xs ys ->
    s_list (k+k) (insert_list (r_list k xs) (r_list k ys))

#[safe]
fn `test_map : (k : int) -> `list k -> `int -> `list k = \k xs y ->
  s_list k (map (\x -> x + r_int y) (r_list k xs))

#[safe]
fn `test_filter : (k : int) -> `list k -> `int -> `list k = \k xs y ->
  s_list k (filter (\x -> x <= r_int y) (r_list k xs))

#[safe]
fn `append : (k : int) -> `list k -> `list k -> `list (k+k) =
  \ k xs ys ->
    s_list (k+k) (append (r_list k xs) (r_list k ys))

#[safe]
fn `take : (k : int) -> `int -> `list k -> `list k =
  \ k n xs ->
    s_list k (take (r_int n) (r_list k xs))

#[safe]
fn `test_concat_map : (k : int) -> `list k -> `int -> `list k =
 \ k xs y ->
  s_list k
   (concat_map 
     (\x -> if x <= r_int y then Cons x Nil else Cons (r_int y) Nil)
     (r_list k xs))

#[safe]
fn `test_parition : (k : int) -> `list k -> `int -> `list k * `list k = \k xs y ->
  let r = tape (case partition (\x -> x <= r_int y) (r_list k xs) of
                 (ys1, ys2) -> `(s_list k ys1, s_list k ys2)
                end)
  in `case r of `(r1, r2) -> (r1, r2) end

#[safe]
fn `test_span : (k : int) -> `list k -> `int -> `list k * `list k = \k xs y ->
  let r = tape (case span (\x -> x <= r_int y) (r_list k xs) of
                 (ys1, ys2) -> `(s_list k ys1, s_list k ys2)
                end)
  in `case r of `(r1, r2) -> (r1, r2) end