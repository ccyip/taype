// This file introduces the basic of the taype language.

data list = Nil | Cons int list

fn length : list -> int = \xs =>
  match xs with
  | Nil => 0
  | Cons _ xs' => 1 + length xs'
  end

fn elem : int -> list -> bool = \y xs =>
  match xs with
  | Nil => false
  | Cons x xs' => if x == y then true else elem y xs'
  end

fn insert : int -> list -> list = \y xs =>
  match xs with
  | Nil => Cons y Nil
  | Cons x xs' => if y <= x then Cons y xs else Cons x (insert y xs')
  end

fn filter : (int -> bool) -> list -> list = \f xs =>
  match xs with
  | Nil => Nil
  | Cons x xs' =>
    let v = filter f xs' in
    if f x then Cons x v else v
  end

fn map : (int -> int) -> list -> list = \f xs =>
  match xs with
  | Nil => Nil
  | Cons x xs' => Cons (f x) (map f xs')
  end

// ----------------------------------------------------------------
// Oblivious list and its instances

obliv ~list (k : int) =
  if k == 0
  then unit
  else unit ~+ ~int ~* ~list (k-1)

fn ~list#s : (k : int) -> list -> ~list k = \k xs =>
  if k == 0
  then ()
  else match xs with
       | Nil => ~inl ()
       | Cons x xs' => ~inr ~(~int#s x, ~list#s (k-1) xs')
       end

fn' ~list#r : (k : int) -> ~list k -> list = \k =>
  if k == 0
  then \_ => Nil
  else \xs => ~match xs with
              | ~inl _ => Nil
              | ~inr ~(x, xs') => Cons (~int#r x) (~list#r (k-1) xs')
              end

fn ~list#Nil : unit -> #~list = \_ =>
  #(0, (() :: ~list 0))

fn ~list#Cons : ~int * #~list -> #~list = \p =>
  match p with
  (x, pxs) =>
    match pxs with
    #(k, xs) =>
      #(k+1, ((~inr ~(x, xs) : unit ~+ ~int ~* ~list k) :: ~list (k+1)))
    end
  end

fn ~list#match : #~list -> (unit -> 'a) -> (~int * #~list -> 'a) -> 'a =
  \pxs f1 f2 =>
    match pxs with
    #(k, xs) =>
      (if k == 0
       then \_ => f1 ()
       else \xs =>
         ~match xs with
         | ~inl _ => f1 ()
         | ~inr ~(x, xs') => f2 (x, #(k-1, xs'))
         end : ~list k -> 'a) xs
    end

fn ~list#view : list -> int = length

fn ~list#join : int -> int -> int = \x y => if x <= y then y else x

fn ~list#reshape : (k : int) -> (k' : int) -> ~list k -> ~list k' = \k k' =>
  if k' == 0
  then \_ => ()
  else
    if k == 0
    then \_ => ~inl ()
    else \xs =>
      ~match xs with
      | ~inl _ => ~inl ()
      | ~inr ~(x, xs') => ~inr ~(x, ~list#reshape (k-1) (k'-1) xs')
      end

// ----------------------------------------------------------------
// Oblivious functions by hand

fn ~elem' : (k : int) -> ~int -> ~list k -> ~bool = \k ~y =>
  if k == 0
  then \_ => ~bool#s false
  else \~xs =>
    ~match ~xs with
    | ~inl _ => ~bool#s false
    | ~inr ~(~x, ~xs') =>
      ~if ~x ~== ~y
      then ~bool#s true
      else ~elem' (k-1) ~y ~xs'
    end

fn ~insert' : (k : int) -> ~int -> ~list k -> ~list (k+1) = \k y =>
  if k == 0
  then \_ => ((~inr ~(y, ()) : unit ~+ ~int ~* unit) :: ~list (k+1))
  else \xs =>
    ~match xs with
    | ~inl _ => ((~inr ~(y, ~list#reshape 0 k (() :: ~list 0))
         : unit ~+ ~int ~* ~list k) :: ~list (k+1))
    | ~inr ~(x, xs') =>
      ~if y ~<= x
      then ((~inr ~(y, xs) : unit ~+ ~int ~* (unit ~+ ~int ~* ~list (k-1)))
             :: ~list (k+1))
      else ((~inr ~(x, ~insert' (k-1) y xs') : unit ~+ ~int ~* ~list (k-1+1))
             :: ~list (k+1))
    end

fn ~filter' : (k : int) -> (~int -> ~bool) -> ~list k -> ~list k = \k f =>
  if k == 0
  then \_ => ()
  else \xs =>
    ~match xs with
    | ~inl _ => ~inl ()
    | ~inr ~(x, xs') =>
      let v = ~filter' (k-1) f xs' in
      ~if f x
      then (~inr ~(x, v) : unit ~+ ~int ~* ~list (k-1))
      else (~list#reshape (k-1) k v :: unit ~+ ~int ~* ~list (k-1))
    end

fn ~test_filter' : (k : int) -> ~list k -> ~int -> ~list k = \k xs y =>
  ~filter' k (\x => x ~<= y) xs

fn ~map' : (k : int) -> (~int -> ~int) -> ~list k -> ~list k = \k f =>
  if k == 0
  then \_ => ()
  else \xs =>
    ~match xs with
    | ~inl _ => ~inl ()
    | ~inr ~(x, xs') =>
      ~inr ~(f x, ~map' (k-1) f xs')
    end

fn ~test_map' : (k : int) -> ~list k -> ~int -> ~list k = \k xs y =>
  ~map' k (\x => x ~+ y) xs

// ----------------------------------------------------------------
// Oblivious functions by preprocessors

fn ~elem_lifted : ~int -> #~list -> ~bool = \y xs =>
  %match #~list ~bool
    xs
    (\_ => %coerce bool ~bool false)
    (\p =>
      match p with
      (x, xs') =>
        %if ~bool ~bool (%== (~int -> ~int -> ~bool) x y)
          (\_ => %coerce bool ~bool true)
          (\_ => ~elem_lifted y xs')
      end)

fn ~insert_lifted : ~int -> #~list -> #~list = \y xs =>
  %match #~list #~list
    xs
    (\_ => %Cons #~list (y, %Nil #~list ()))
    (\p =>
      match p with
      (x, xs') =>
        %if ~bool #~list (%<= (~int -> ~int -> ~bool) y x)
          (\_ => %Cons #~list (y, xs))
          (\_ => %Cons #~list (x, ~insert_lifted y xs'))
      end)

fn ~filter_lifted : (~int -> ~bool) -> #~list -> #~list = \f xs =>
  %match #~list #~list
    xs
    (\_ => %Nil #~list ())
    (\p =>
      match p with
      (x, xs') =>
        let v = ~filter_lifted f xs' in
        %if ~bool #~list (f x)
          (\_ => %Cons #~list (x, v))
          (\_ => v)
      end)

fn ~map_lifted : (~int -> ~int) -> #~list -> #~list = \f xs =>
  %match #~list #~list
    xs
    (\_ => %Nil #~list ())
    (\p =>
      match p with
      (x, xs') =>
        %Cons #~list (f x, ~map_lifted f xs')
      end)

// ----------------------------------------------------------------
// Oblivious functions by lifting

fn ~elem : ~int -> #~list -> ~bool = %lift elem
fn ~insert : ~int -> #~list -> #~list = %lift insert
fn ~map : (~int -> ~int) -> #~list -> #~list = %lift map
fn ~filter : (~int -> ~bool) -> #~list -> #~list = %lift filter

fn ~test_map : #~list -> ~int -> #~list = \xs y =>
  ~map (\x => x ~+ y) xs

fn ~test_filter : #~list -> ~int -> #~list = \xs y =>
  ~filter (\x => x ~<= y) xs

// ----------------------------------------------------------------
// Oblivious list with extact length and its instances

obliv ~list_eq (k : int) =
  if k == 0
  then unit
  else ~int ~* ~list_eq (k-1)

fn ~list_eq#s : (k : int) -> list -> ~list_eq k = \k xs =>
  if k == 0
  then ()
  else match xs with
       | Nil => ~~
       | Cons x xs' => ~(~int#s x, ~list_eq#s (k-1) xs')
       end

fn' ~list_eq#r : (k : int) -> ~list_eq k -> list = \k =>
  if k == 0
  then \_ => Nil
  else \xs => ~match xs with
              ~(x, xs') => Cons (~int#r x) (~list_eq#r (k-1) xs')
              end

fn ~list_eq#Nil : unit -> #~list_eq = \_ =>
  #(0, (() :: ~list_eq 0))

fn ~list_eq#Cons : ~int * #~list_eq -> #~list_eq = \p =>
  match p with
  (x, pxs) =>
    match pxs with
    #(k, xs) =>
      #(k+1, (~(x, xs) :: ~list_eq (k+1)))
    end
  end

fn ~list_eq#match : #~list_eq -> (unit -> 'a) -> (~int * #~list_eq -> 'a) -> 'a =
  \pxs f1 f2 =>
    match pxs with
    #(k, xs) =>
      (if k == 0
       then \_ => f1 ()
       else \xs =>
         ~match xs with
         | ~(x, xs') => f2 (x, #(k-1, xs'))
         end : ~list_eq k -> 'a) xs
    end

fn ~list_eq#view : list -> int = length

fn ~list_eq#~list#coerce : #~list_eq -> #~list = \pxs =>
  %match #~list_eq #~list pxs
    (\_ => ~list#Nil ())
    (\xs =>
      match xs with
      (x, xs') => ~list#Cons (x, ~list_eq#~list#coerce xs')
      end)

// ----------------------------------------------------------------
// Oblivious list with maximum length and element indicator

// obliv ~list_filter (k : int) =
//   if k == 0
//   then unit
//   else ~bool ~* ~int ~* ~list_filter (k-1)

// fn ~list_filter_pad : (k : int) -> ~list_filter k = \k =>
//   if k == 0
//   then ()
//   else ~(~bool#s false, ~~, ~list_filter_pad (k-1))

// fn ~list_filter#s : (k : int) -> list -> ~list_filter k = \k xs =>
//   if k == 0
//   then ()
//   else match xs with
//        | Nil =>
//            // ~list_filter_pad k
//            ~(~bool#s false, ~~, ~list_filter_pad (k-1))
//        | Cons x xs' => ~(~bool#s true, ~int#s x, ~list_filter#s (k-1) xs')
//        end

// fn' ~list_filter#r : (k : int) -> ~list_filter k -> list = \k =>
//   if k == 0
//   then \_ => Nil
//   else \xs =>
//     ~match xs with
//     ~(b, x, xs') =>
//       if ~bool#r b then Cons (~int#r x) (~list_filter#r (k-1) xs')
//       else ~list_filter#r (k-1) xs'
//     end

// fn ~list_filter#Nil : unit -> #~list_filter = \_ =>
//   #(0, (() :: ~list_filter 0))

// fn ~list_filter#Cons : ~int * #~list_filter -> #~list_filter = \p =>
//   match p with
//   (x, pxs) =>
//     match pxs with
//     #(k, xs) =>
//       #(k+1, (~(~bool#s true, x, xs) :: ~list_filter (k+1)))
//     end
//   end

// fn ~list_filter#match :
//   #~list_filter -> (unit -> 'a) -> (~int * #~list_filter -> 'a) -> 'a =
//   \pxs f1 f2 =>
//     match pxs with
//     #(k, xs) =>
//       (if k == 0
//        then \_ => f1 ()
//        else \xs =>
//          ~match xs with
//          ~(b, x, xs') =>
//            ~if b then f2 (x, #(k-1, xs'))
//            else ~list_filter#match #(k-1, xs') f1 f2
//          end : ~list_filter k -> 'a) xs
//     end

// fn ~list_filter#view : list -> int = length

// fn ~list_filter#join : int -> int -> int = \x y => if x <= y then y else x

// fn ~list_filter_app :
//   (k : int) -> (k' : int) -> ~list_filter k -> ~list_filter k' ->
//   ~list_filter (k + k') = \k k' =>
//   if k == 0
//   then \_ ys => (ys :: ~list_filter (k + k'))
//   else \xs ys =>
//     ~match xs with
//     ~(b, x, xs') =>
//       (~(b, x, ~list_filter_app (k-1) k' xs' ys) :: ~list_filter (k + k'))
//     end

// fn ~list_filter#reshape :
//   (k : int) -> (k' : int) -> ~list_filter k -> ~list_filter k' = \k k' xs =>
//   (~list_filter_app (k'-k) k (~list_filter_pad (k'-k)) xs :: ~list_filter k')
